// Binary gensort generates a sort function for arbitrary type T and for arbitrary compare functions.
package main

import (
	"flag"
	"log"
	"os"
	"text/template"
)

var (
	output      = flag.String("output", "/dev/stdout", "The name of the file to write generated contents to")
	target      = flag.String("type", "int", "The type of the slice to generate sort function for")
	packageName = flag.String("package", "main", "The package name to put generated sort function under")
	funcName    = flag.String("name", "quickSort", "The name of the sort func")
	less        = flag.String("less", "x < y", "The 'less' expression to use")
	eq          = flag.String("eq", "x == y", "The 'equal' expression to use")
	receiver    = flag.String("receiver", "", "The receiver of the sorting func, if empty no receiver will be used")

	tmpl = `/* generated by gensort */
package {{.package}}

import (
	"math/rand"
	"sync"
)

func {{if .receiver}}({{.receiver}}) {{end}}{{.name}}(_xs []{{.T}}) {
	_partition := func(_xs []{{.T}}) (_low, _high []{{.T}}) {
		var (
			_chosen = rand.Intn(len(_xs))
			y       = _xs[_chosen]
		)

		_i, _j := 0, 0
		for _k, x := range _xs {
			if {{.less}} {
				_xs[_k] = _xs[_j]
				_xs[_j] = _xs[_i]
				_xs[_i] = x
				_i++
				_j++
			} else if {{.eq}} {
				_xs[_k] = _xs[_j]
				_xs[_j] = x
				_j++
			}
		}

		return _xs[:_i], _xs[_j:]
	}

	const threshold = 1000
	var wg sync.WaitGroup
	var {{.name}} func([]{{.T}})
	{{.name}} = func(xs []{{.T}}) {
	init:
		if len(xs) <= 1 {
			return
		}

		low, high := _partition(xs)

		var short, long []{{.T}}
		if len(low) < len(high) {
			short, long = low, high
		} else {
			short, long = high, low
		}

		if len(short) > threshold {
			short := short
			wg.Add(1)
			go func() {
				{{.name}}(short)
				wg.Done()
			}()
		} else {
			{{.name}}(short)
		}
		xs = long
		goto init
	}

	{{.name}}(_xs)
	wg.Wait()
}
`
)

func main() {
	flag.Parse()

	file, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}

	model := map[string]string{
		"T":        *target,
		"package":  *packageName,
		"less":     *less,
		"eq":       *eq,
		"name":     *funcName,
		"receiver": *receiver,
	}

	t := template.Must(template.New("Main").Parse(tmpl))
	if err := t.Execute(file, model); err != nil {
		log.Fatal(err)
	}
}
